#!/usr/bin/env node

/**
 * Generate TypeScript types from modular OpenAPI specifications
 * Usage: node scripts/generate-api-types.ts
 */

import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import { writeFileSync } from 'fs';
import generateSchema, { astToString } from 'openapi-typescript';
import type { OpenAPI3 } from 'openapi-typescript';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const outputFile = join(__dirname, '../api-types/generated-types.d.ts');

const bannerComment = `/**
 * ‚ö†Ô∏è  AUTO-GENERATED FILE - DO NOT MODIFY ‚ö†Ô∏è
 *
 * This file is automatically generated from OpenAPI specifications.
 *
 * To regenerate this file after updating OpenAPI specs:
 * 1. Update your OpenAPI specification files in open-api-specs/
 * 2. Run: cd shared && pnpm generate-types
 *
 * This ensures type safety between your API contracts and TypeScript code.
 */

`;

async function generateApiTypes() {
  try {
    console.log('üîß Importing OpenAPI specs...');
    const specsModule = await import('../open-api-specs/index');
    const specExports = Object.keys(specsModule);
    console.log(
      `üìÅ Found ${specExports.length} spec exports: ${specExports.join(', ')}`
    );

    // Base OpenAPI specification (OpenAPI 3.1)
    const baseOpenApi: OpenAPI3 = {
      openapi: '3.1.0',
      info: {
        title: 'App Template API',
        version: '1.0.0',
        description: 'API for managing application entities',
      },
      servers: [{ url: '/api/v1', description: 'API v1', variables: {} }],
      components: {
        schemas: {
          ApiErrorResponse: {
            type: 'object',
            properties: {
              error: {
                type: 'object',
                properties: {
                  message: { type: 'string' },
                  code: { type: 'string' },
                  details: { type: 'object' },
                },
                required: ['message'],
              },
            },
            required: ['error'],
          },
        },
      },
      paths: {},
    };

    // Combine specs
    console.log('üîó Combining OpenAPI specifications...');

    // Collect all schemas and paths from namespaced exports
    const allSchemas: Record<string, unknown> = {};
    const allPaths: Record<string, unknown> = {};

    // Process all exports to find schemas and paths
    for (const [exportName, exportValue] of Object.entries(specsModule)) {
      if (
        exportName.endsWith('Schemas') &&
        typeof exportValue === 'object' &&
        exportValue !== null
      ) {
        Object.assign(allSchemas, exportValue);
      } else if (
        exportName.endsWith('Paths') &&
        typeof exportValue === 'object' &&
        exportValue !== null
      ) {
        Object.assign(allPaths, exportValue);
      }
    }

    if (Object.keys(allSchemas).length > 0 && baseOpenApi.components?.schemas) {
      Object.assign(baseOpenApi.components.schemas, allSchemas);
      console.log(`üìã Combined ${Object.keys(allSchemas).length} schemas`);
    }
    if (Object.keys(allPaths).length > 0 && baseOpenApi.paths) {
      Object.assign(baseOpenApi.paths, allPaths);
      console.log(`üõ£Ô∏è  Combined ${Object.keys(allPaths).length} paths`);
    }

    // Generate and write types
    console.log('üîß Generating TypeScript types...');
    const typescriptTypes = await generateSchema(baseOpenApi);
    const typescriptTypesString = bannerComment + astToString(typescriptTypes);
    writeFileSync(outputFile, typescriptTypesString);

    console.log('‚úÖ API types generated successfully!');
    console.log(`üìÅ Output: ${outputFile}`);
    console.log(`üìä Combined ${specExports.length} OpenAPI spec files`);
  } catch (error) {
    console.error('‚ùå Failed to generate API types:', (error as Error).message);
    process.exit(1);
  }
}

generateApiTypes();
